<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart 2D Map Generator</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="header">
        <h1>Smart 2D Map Generator</h1>
        <p style="color: #aaa;">AI-powered tile classification and intelligent map generation</p>
    </div>

    <div class="container">
        <div class="sidebar">
            <div class="section">
                <h3>1. Upload Tileset</h3>
                <div class="upload-area" id="uploadArea">
                    <p>ðŸŽ¨ Drop tileset image here</p>
                    <p style="margin-top: 10px; color: #666; font-size: 0.9rem;">or click to browse</p>
                </div>
                <input type="file" id="fileInput" accept="image/*">
                
                <div id="textureMode" style="display: none; margin-top: 15px;">
                    <div class="control-group">
                        <label>Texture Type:</label>
                        <select id="textureModeSelect" onchange="reprocessTexture()">
                            <option value="single">Single Texture</option>
                            <option value="atlas" selected>Tile Atlas</option>
                        </select>
                    </div>
                    <div id="atlasControls" style="display: none; margin-top: 10px;">
                        <div class="control-group">
                            <label>Atlas Grid:</label>
                            <select id="atlasGrid" onchange="reprocessTexture()">
                                <option value="auto">Auto-detect Grid</option>
                                <option value="2x2">2Ã—2</option>
                                <option value="4x4">4Ã—4</option>
                                <option value="8x8">8Ã—8</option>
                                <option value="16x16">16Ã—16</option>
                                <option value="custom">Custom</option>
                            </select>
                        </div>
                        <div id="customGrid" style="display: none;">
                            <div class="control-group">
                                <label>Columns:</label>
                                <input type="number" id="customCols" value="4" min="1" max="32" onchange="reprocessTexture()">
                            </div>
                            <div class="control-group">
                                <label>Rows:</label>
                                <input type="number" id="customRows" value="4" min="1" max="32" onchange="reprocessTexture()">
                            </div>
                        </div>
                    </div>
                    <div id="processingResult" style="margin-top: 8px; padding: 8px; background: #0a0a0a; border-radius: 4px; font-size: 0.85rem;"></div>
                </div>
            </div>

            <div class="section" id="tilesSection" style="display: none;">
                <h3>2. Classify Tiles</h3>
                <p style="color: #aaa; font-size: 0.9rem; margin-bottom: 15px;">Select tiles and assign them to categories. Multiple selection with Ctrl+Click.</p>
                
                <div class="tile-classification-controls" style="margin-bottom: 15px;">
                    <div class="control-group">
                        <label>Selected tiles are:</label>
                        <select id="tileAssignType">
                            <option value="floor">Floors (base layer)</option>
                            <option value="wall">Walls (obstacles)</option>
                            <option value="decoration">Decorations (overlays)</option>
                        </select>
                        <button class="btn btn-secondary" onclick="assignSelectedTiles()" style="width: auto; padding: 8px 16px; font-size: 0.8rem;">Assign</button>
                    </div>
                </div>
                
                <div class="tiles-preview" id="tilesPreview"></div>
                <div class="tile-stats" id="tileStats"></div>
            </div>

            <div class="section">
                <h3>3. Map Settings</h3>
                <div class="controls">
                    <div class="control-group">
                        <label>Map Size:</label>
                        <select id="mapSize">
                            <option value="16">16x16</option>
                            <option value="32" selected>32x32</option>
                            <option value="64">64x64</option>
                            <option value="128">128x128</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Tile Size:</label>
                        <input type="number" id="tileSize" value="32" min="8" max="128">
                    </div>
                    <div class="control-group">
                        <label>Grid Opacity:</label>
                        <input type="range" id="gridOpacity" min="0" max="100" value="0" style="flex: 1; margin-left: 10px;" oninput="updateGridOpacity()">
                        <span id="gridOpacityValue" style="color: #00ff88; font-size: 0.8rem; min-width: 30px; text-align: right;">0%</span>
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>4. Generation Options</h3>
                <div class="checkbox-group" id="assetTypes">
                    <div class="checkbox-item">
                        <input type="checkbox" id="useFloors" checked>
                        <label for="useFloors">Floors</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="useWalls" checked>
                        <label for="useWalls">Walls</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="useDecorations" checked>
                        <label for="useDecorations">Decorations</label>
                    </div>
                </div>
                
                <div class="control-group" style="margin-top: 15px;">
                    <label>Environment Type:</label>
                    <select id="environmentType">
                        <option value="auto">Auto-detect from tiles</option>
                        <option value="dungeon">Dungeon (rooms & corridors)</option>
                        <option value="tavern">Tavern/Inn (tables, bar, furniture)</option>
                        <option value="castle">Castle (throne room, chambers)</option>
                        <option value="nature">Nature (wilderness, paths)</option>
                        <option value="city">City (streets, buildings)</option>
                        <option value="abstract">Abstract/Mixed</option>
                    </select>
                </div>
            </div>

            <button class="btn" onclick="generateMap()">Generate Map</button>
            <button class="btn btn-secondary" onclick="exportMap()" style="margin-top: 10px;">Export as PNG</button>
            
            <div class="section" id="paintSection" style="display: none; margin-top: 20px;">
                <h3>5. Paint Mode</h3>
                <p style="color: #aaa; font-size: 0.9rem; margin-bottom: 10px;">Click tile preview to select paint tile, then drag on map to paint.</p>
                <div id="paintTilePreview" style="width: 48px; height: 48px; border: 2px solid #333; border-radius: 4px; background: #0a0a0a; margin-bottom: 10px; cursor: pointer;" onclick="showTileSelector()"></div>
                <button class="btn btn-secondary" onclick="togglePaintMode()" id="paintModeBtn">Enable Paint Mode</button>
                
                <!-- Tile Selector Popup -->
                <div id="tileSelectorPopup" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; border: 2px solid #333; border-radius: 8px; padding: 20px; z-index: 1000; max-width: 500px; max-height: 400px; overflow-y: auto;">
                    <h4 style="color: #00ff88; margin-bottom: 15px;">Select Paint Tile</h4>
                    <div id="tileSelectorGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(48px, 1fr)); gap: 8px; margin-bottom: 15px;"></div>
                    <button class="btn btn-secondary" onclick="closeTileSelector()" style="width: 100%;">Close</button>
                </div>
                <div id="tileSelectorOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;" onclick="closeTileSelector()"></div>
            </div>
        </div>

        <div class="main-area">
            <div class="canvas-container">
                <canvas id="outputCanvas"></canvas>
            </div>
        </div>
    </div>

    <div class="status" id="status"></div>

    <script src="script.js"></script>
</body>
</html>
                <div class="controls">
                    <div class="control-group">
                        <label>Map Size:</label>
                        <select id="mapSize">
                            <option value="16">16x16</option>
                            <option value="32" selected>32x32</option>
                            <option value="64">64x64</option>
                            <option value="128">128x128</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Tile Size:</label>
                        <input type="number" id="tileSize" value="32" min="8" max="128">
                    </div>
                    <div class="control-group">
                        <label>Grid Opacity:</label>
                        <input type="range" id="gridOpacity" min="0" max="100" value="0" style="flex: 1; margin-left: 10px;" oninput="updateGridOpacity()">
                        <span id="gridOpacityValue" style="color: #00ff88; font-size: 0.8rem; min-width: 30px; text-align: right;">0%</span>
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>4. Generation Options</h3>
                <div class="checkbox-group" id="assetTypes">
                    <div class="checkbox-item">
                        <input type="checkbox" id="useFloors" checked>
                        <label for="useFloors">Floors</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="useWalls" checked>
                        <label for="useWalls">Walls</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="useDecorations" checked>
                        <label for="useDecorations">Decorations</label>
                    </div>
                </div>
                
                <div class="control-group" style="margin-top: 15px;">
                    <label>Environment Type:</label>
                    <select id="environmentType">
                        <option value="auto">Auto-detect from tiles</option>
                        <option value="dungeon">Dungeon (rooms & corridors)</option>
                        <option value="tavern">Tavern/Inn (tables, bar, furniture)</option>
                        <option value="castle">Castle (throne room, chambers)</option>
                        <option value="nature">Nature (wilderness, paths)</option>
                        <option value="city">City (streets, buildings)</option>
                        <option value="abstract">Abstract/Mixed</option>
                    </select>
                </div>
            </div>

            <button class="btn" onclick="generateMap()">Generate Map</button>
            <button class="btn btn-secondary" onclick="exportMap()" style="margin-top: 10px;">Export as PNG</button>
            
            <div class="section" id="paintSection" style="display: none; margin-top: 20px;">
                <h3>5. Paint Mode</h3>
                <p style="color: #aaa; font-size: 0.9rem; margin-bottom: 10px;">Click tile preview to select paint tile, then drag on map to paint.</p>
                <div id="paintTilePreview" style="width: 48px; height: 48px; border: 2px solid #333; border-radius: 4px; background: #0a0a0a; margin-bottom: 10px; cursor: pointer;" onclick="showTileSelector()"></div>
                <button class="btn btn-secondary" onclick="togglePaintMode()" id="paintModeBtn">Enable Paint Mode</button>
                
                <!-- Tile Selector Popup -->
                <div id="tileSelectorPopup" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; border: 2px solid #333; border-radius: 8px; padding: 20px; z-index: 1000; max-width: 500px; max-height: 400px; overflow-y: auto;">
                    <h4 style="color: #00ff88; margin-bottom: 15px;">Select Paint Tile</h4>
                    <div id="tileSelectorGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(48px, 1fr)); gap: 8px; margin-bottom: 15px;"></div>
                    <button class="btn btn-secondary" onclick="closeTileSelector()" style="width: 100%;">Close</button>
                </div>
                <div id="tileSelectorOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;" onclick="closeTileSelector()"></div>
            </div>
        </div>

        <div class="main-area">
            <div class="canvas-container">
                <canvas id="outputCanvas" style="border: 2px solid #333; image-rendering: pixelated; max-width: 100%; max-height: 100%;"></canvas>
            </div>
        </div>
    </div>

    <div class="status" id="status"></div>

    <script>
        let tilesetImage = null;
        let tiles = [];
        let selectedTiles = new Set();
        let tileClassifications = new Map();
        let currentMap = null;
        let paintMode = false;
        let paintTileIndex = null;
        let tileStates = {}; // Track tile selection states
        let manualClassification = { floor: [], wall: [], decoration: [] }; // Manual tile assignments
        let gridOpacity = 0; // Grid opacity from 0 to 1
        let isMapGenerated = false;
        let tileSize = 32;
        
        // Canvas elements
        const mapCanvas = document.getElementById('outputCanvas');
        const mapCtx = mapCanvas.getContext('2d');

        // Smart tile analysis using visual features
        class TileAnalyzer {
            static analyzeTexture(imageData) {
                const data = imageData.data;
                let edges = 0;
                let variance = 0;
                let avgBrightness = 0;
                
                for (let i = 0; i < data.length; i += 4) {
                    const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                    avgBrightness += brightness;
                    
                    if (i > 0 && Math.abs(brightness - (data[i-4] + data[i-3] + data[i-2]) / 3) > 30) {
                        edges++;
                    }
                }
                
                avgBrightness /= (data.length / 4);
                
                let colorSum = [0, 0, 0];
                for (let i = 0; i < data.length; i += 4) {
                    colorSum[0] += data[i];
                    colorSum[1] += data[i+1];
                    colorSum[2] += data[i+2];
                }
                
                const avgColor = colorSum.map(c => c / (data.length / 4));
                for (let i = 0; i < data.length; i += 4) {
                    variance += Math.abs(data[i] - avgColor[0]) + 
                               Math.abs(data[i+1] - avgColor[1]) + 
                               Math.abs(data[i+2] - avgColor[2]);
                }
                variance /= (data.length / 4);
                
                return { edges, variance, avgBrightness };
            }

            static classifyTile(canvas, index) {
                try {
                    const ctx = canvas.getContext('2d');
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const features = this.analyzeTexture(imageData);
                    const dominantColor = this.getDominantColor(imageData);
                    
                    if (features.edges < 50 && features.variance < 30) {
                        return this.classifyByColor(dominantColor, 'floor');
                    } else if (features.edges > 200 || features.avgBrightness < 50) {
                        return this.classifyByColor(dominantColor, 'wall');
                    } else if (features.variance > 100) {
                        return 'decoration';
                    } else {
                        return this.classifyByColor(dominantColor, 'floor');
                    }
                } catch (error) {
                    console.warn('Tile classification error:', error);
                    return 'floor';
                }
            }

            static getDominantColor(imageData) {
                const data = imageData.data;
                let r = 0, g = 0, b = 0;
                const pixelCount = data.length / 4;
                
                for (let i = 0; i < data.length; i += 4) {
                    r += data[i];
                    g += data[i + 1];
                    b += data[i + 2];
                }
                
                return {
                    r: r / pixelCount,
                    g: g / pixelCount,
                    b: b / pixelCount
                };
            }

            static classifyByColor(color, defaultType) {
                const { r, g, b } = color;
                const brightness = (r + g + b) / 3;
                
                if (g > r && g > b && g > 100) return 'floor'; // Green
                if (r > 100 && g > 80 && b < 80) return 'floor'; // Brown/earthy
                if (brightness < 60 || (Math.abs(r - g) < 20 && Math.abs(g - b) < 20 && brightness < 120)) return 'wall'; // Dark or gray
                
                return defaultType;
            }
        }

        // Map generation with intelligent placement
        class MapGenerator {
            static generate(width, height, tilesByType, environmentType) {
                const map = Array(height).fill(null).map(() => Array(width).fill(null));
                return this.generateByEnvironment(map, tilesByType, environmentType);
            }

            static generateByEnvironment(map, tilesByType, environmentType) {
                switch(environmentType) {
                    case 'nature':
                        return this.generateNature(map, tilesByType);
                    case 'dungeon':
                        return this.generateDungeon(map, tilesByType);
                    case 'city':
                        return this.generateCity(map, tilesByType);
                    case 'auto':
                        return this.generateAuto(map, tilesByType);
                    case 'abstract':
                    default:
                        return this.generateTopDown(map, tilesByType);
                }
            }

            static generateNature(map, tilesByType) {
                const height = map.length;
                const width = map[0].length;
                
                // Base layer: mostly grass/ground
                const floors = tilesByType.floor || [];
                if (floors.length > 0) {
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            map[y][x] = floors[Math.floor(Math.random() * floors.length)];
                        }
                    }
                }
                
                // Water features (walls can be water)
                const walls = tilesByType.wall || [];
                if (walls.length > 0) {
                    // Create a river or pond
                    if (Math.random() > 0.5) {
                        // River
                        const riverY = Math.floor(height * (0.3 + Math.random() * 0.4));
                        for (let x = 0; x < width; x++) {
                            map[riverY][x] = walls[Math.floor(Math.random() * walls.length)];
                            if (Math.random() > 0.7 && riverY + 1 < height) {
                                map[riverY + 1][x] = walls[Math.floor(Math.random() * walls.length)];
                            }
                        }
                    } else {
                        // Pond
                        const centerX = Math.floor(width / 2);
                        const centerY = Math.floor(height / 2);
                        const radius = Math.floor(Math.min(width, height) * 0.15);
                        
                        for (let y = centerY - radius; y <= centerY + radius; y++) {
                            for (let x = centerX - radius; x <= centerX + radius; x++) {
                                if (x >= 0 && x < width && y >= 0 && y < height) {
                                    const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                                    if (dist <= radius) {
                                        map[y][x] = walls[Math.floor(Math.random() * walls.length)];
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Trees and rocks (decorations)
                const decorations = tilesByType.decoration || [];
                if (decorations.length > 0) {
                    // Scattered trees/rocks
                    const numClusters = Math.floor(Math.random() * 4) + 3;
                    for (let i = 0; i < numClusters; i++) {
                        const clusterX = Math.floor(Math.random() * width);
                        const clusterY = Math.floor(Math.random() * height);
                        const clusterSize = Math.floor(Math.random() * 5) + 2;
                        
                        for (let j = 0; j < clusterSize; j++) {
                            const x = clusterX + Math.floor(Math.random() * 6) - 3;
                            const y = clusterY + Math.floor(Math.random() * 6) - 3;
                            
                            if (x >= 0 && x < width && y >= 0 && y < height) {
                                map[y][x] = decorations[Math.floor(Math.random() * decorations.length)];
                            }
                        }
                    }
                }
                
                return map;
            }

            static generateDungeon(map, tilesByType) {
                const height = map.length;
                const width = map[0].length;
                
                // Start with walls everywhere
                const walls = tilesByType.wall || [];
                if (walls.length > 0) {
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            map[y][x] = walls[Math.floor(Math.random() * walls.length)];
                        }
                    }
                }
                
                // Carve out rooms and corridors with floors
                const floors = tilesByType.floor || [];
                if (floors.length > 0) {
                    // Generate rooms
                    const numRooms = Math.floor(Math.random() * 4) + 3;
                    const rooms = [];
                    
                    for (let i = 0; i < numRooms; i++) {
                        const roomWidth = Math.floor(Math.random() * 8) + 4;
                        const roomHeight = Math.floor(Math.random() * 8) + 4;
                        const roomX = Math.floor(Math.random() * (width - roomWidth - 2)) + 1;
                        const roomY = Math.floor(Math.random() * (height - roomHeight - 2)) + 1;
                        
                        rooms.push({ x: roomX, y: roomY, width: roomWidth, height: roomHeight });
                        
                        // Fill room with floor
                        for (let y = roomY; y < roomY + roomHeight; y++) {
                            for (let x = roomX; x < roomX + roomWidth; x++) {
                                map[y][x] = floors[Math.floor(Math.random() * floors.length)];
                            }
                        }
                    }
                    
                    // Connect rooms with corridors
                    for (let i = 0; i < rooms.length - 1; i++) {
                        const room1 = rooms[i];
                        const room2 = rooms[i + 1];
                        
                        const x1 = room1.x + Math.floor(room1.width / 2);
                        const y1 = room1.y + Math.floor(room1.height / 2);
                        const x2 = room2.x + Math.floor(room2.width / 2);
                        const y2 = room2.y + Math.floor(room2.height / 2);
                        
                        // Horizontal corridor
                        for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {
                            map[y1][x] = floors[Math.floor(Math.random() * floors.length)];
                        }
                        
                        // Vertical corridor
                        for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {
                            map[y][x2] = floors[Math.floor(Math.random() * floors.length)];
                        }
                    }
                }
                
                // Add decorations (torches, furniture, etc.)
                const decorations = tilesByType.decoration || [];
                if (decorations.length > 0) {
                    for (let y = 1; y < height - 1; y++) {
                        for (let x = 1; x < width - 1; x++) {
                            // Place decorations on floor tiles near walls
                            if (!walls.includes(map[y][x]) && Math.random() < 0.05) {
                                let nearWall = false;
                                for (let dy = -1; dy <= 1; dy++) {
                                    for (let dx = -1; dx <= 1; dx++) {
                                        if (y + dy >= 0 && y + dy < height && x + dx >= 0 && x + dx < width && 
                                            walls.includes(map[y + dy][x + dx])) {
                                            nearWall = true;
                                            break;
                                        }
                                    }
                                    if (nearWall) break;
                                }
                                if (nearWall) {
                                    map[y][x] = decorations[Math.floor(Math.random() * decorations.length)];
                                }
                            }
                        }
                    }
                }
                
                return map;
            }

            static generateCity(map, tilesByType) {
                const height = map.length;
                const width = map[0].length;
                
                // Base with road/ground material
                const floors = tilesByType.floor || [];
                if (floors.length > 0) {
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            map[y][x] = floors[Math.floor(Math.random() * floors.length)];
                        }
                    }
                }
                
                // Create a grid of roads
                const walls = tilesByType.wall || [];
                if (walls.length > 0) {
                    // Vertical roads
                    for (let x = 8; x < width; x += 12) {
                        for (let y = 0; y < height; y++) {
                            map[y][x] = walls[Math.floor(Math.random() * walls.length)];
                            if (x + 1 < width) {
                                map[y][x + 1] = walls[Math.floor(Math.random() * walls.length)];
                            }
                        }
                    }
                    
                    // Horizontal roads
                    for (let y = 8; y < height; y += 12) {
                        for (let x = 0; x < width; x++) {
                            map[y][x] = walls[Math.floor(Math.random() * walls.length)];
                            if (y + 1 < height) {
                                map[y + 1][x] = walls[Math.floor(Math.random() * walls.length)];
                            }
                        }
                    }
                }
                
                // Add buildings/decorations
                const decorations = tilesByType.decoration || [];
                if (decorations.length > 0) {
                    // Fill blocks with buildings
                    for (let blockY = 0; blockY < height; blockY += 12) {
                        for (let blockX = 0; blockX < width; blockX += 12) {
                            if (Math.random() > 0.3) { // 70% chance of building
                                for (let y = blockY + 1; y < Math.min(blockY + 7, height); y++) {
                                    for (let x = blockX + 1; x < Math.min(blockX + 7, width); x++) {
                                        if (Math.random() > 0.2) {
                                            map[y][x] = decorations[Math.floor(Math.random() * decorations.length)];
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                return map;
            }

            static generateAuto(map, tilesByType) {
                // Simple heuristic based on tile types available
                const hasWater = tilesByType.wall && tilesByType.wall.length > 0;
                const hasVegetation = tilesByType.decoration && tilesByType.decoration.length > 0;
                
                if (hasWater && hasVegetation) {
                    return this.generateNature(map, tilesByType);
                } else if (tilesByType.wall && tilesByType.wall.length > tilesByType.floor.length) {
                    return this.generateDungeon(map, tilesByType);
                } else {
                    return this.generateTopDown(map, tilesByType);
                }
            }

            static generateTopDown(map, tilesByType) {
                const height = map.length;
                const width = map[0].length;
                
                // Fill with floor tiles
                const floors = tilesByType.floor || [];
                if (floors.length > 0) {
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            map[y][x] = floors[Math.floor(Math.random() * floors.length)];
                        }
                    }
                }
                
                // Add walls around edges
                const walls = tilesByType.wall || [];
                if (walls.length > 0) {
                    for (let x = 0; x < width; x++) {
                        map[0][x] = walls[Math.floor(Math.random() * walls.length)];
                        map[height-1][x] = walls[Math.floor(Math.random() * walls.length)];
                    }
                    for (let y = 0; y < height; y++) {
                        map[y][0] = walls[Math.floor(Math.random() * walls.length)];
                        map[y][width-1] = walls[Math.floor(Math.random() * walls.length)];
                    }
                }
                
                // Add decorations
                const decorations = tilesByType.decoration || [];
                if (decorations.length > 0) {
                    const numDecorations = Math.floor((width * height) * 0.1);
                    for (let i = 0; i < numDecorations; i++) {
                        const x = Math.floor(Math.random() * width);
                        const y = Math.floor(Math.random() * height);
                        map[y][x] = decorations[Math.floor(Math.random() * decorations.length)];
                    }
                }
                
                return map;
            }
        }

        // UI handlers
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFile(e.dataTransfer.files[0]);
        });

        fileInput.addEventListener('change', (e) => {
            handleFile(e.target.files[0]);
        });

        function handleFile(file) {
            if (!file || !file.type.startsWith('image/')) {
                showStatus('Please upload an image file', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                tilesetImage = new Image();
                tilesetImage.onload = () => {
                    document.getElementById('textureMode').style.display = 'block';
                    updateModeVisibility();
                    extractTiles();
                    showStatus('Tileset loaded successfully!', 'success');
                };
                tilesetImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function updateModeVisibility() {
            const mode = document.getElementById('textureModeSelect').value;
            const atlasControls = document.getElementById('atlasControls');
            const customGrid = document.getElementById('customGrid');
            
            if (mode === 'atlas') {
                atlasControls.style.display = 'block';
                const gridValue = document.getElementById('atlasGrid').value;
                customGrid.style.display = gridValue === 'custom' ? 'block' : 'none';
            } else {
                atlasControls.style.display = 'none';
                customGrid.style.display = 'none';
            }
        }

        function reprocessTexture() {
            if (tilesetImage) {
                updateModeVisibility();
                extractTiles();
                showStatus('Texture reprocessed!', 'success');
            }
        }

        // Event listeners
        document.getElementById('tileSize').addEventListener('change', () => {
            if (tilesetImage) {
                reprocessTexture();
            }
        });

        document.getElementById('atlasGrid').addEventListener('change', () => {
            updateModeVisibility();
            if (tilesetImage) {
                reprocessTexture();
            }
        });

        document.getElementById('gridOpacity').addEventListener('input', updateGridOpacity);

        function extractTiles() {
            const tileSize = parseInt(document.getElementById('tileSize').value);
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            tiles = [];
            tileClassifications.clear();
            selectedTiles.clear();
            
            const modeSelect = document.getElementById('textureModeSelect');
            const mode = modeSelect.value;
            
            canvas.width = tileSize;
            canvas.height = tileSize;
            
            if (mode === 'single') {
                extractSingleTexture(canvas, ctx, tileSize);
            } else {
                extractAtlasTiles(canvas, ctx, tileSize);
            }
            
            displayTiles();
            updateTileStats();
        }

        function extractSingleTexture(canvas, ctx, tileSize) {
            // Scale image to fit tile size while maintaining aspect ratio
            const scale = Math.min(tileSize / tilesetImage.width, tileSize / tilesetImage.height);
            const scaledWidth = tilesetImage.width * scale;
            const scaledHeight = tilesetImage.height * scale;
            const offsetX = (tileSize - scaledWidth) / 2;
            const offsetY = (tileSize - scaledHeight) / 2;
            
            ctx.clearRect(0, 0, tileSize, tileSize);
            ctx.drawImage(
                tilesetImage,
                0, 0, tilesetImage.width, tilesetImage.height,
                offsetX, offsetY, scaledWidth, scaledHeight
            );
            
            const tileData = canvas.toDataURL();
            tiles.push(tileData);
            
            const classification = TileAnalyzer.classifyTile(canvas, 0);
            tileClassifications.set(0, classification);
            selectedTiles.add(0);
            
            updateProcessingResult(`Single texture processed (${tilesetImage.width}Ã—${tilesetImage.height}px)`, 'success');
        }

        function extractAtlasTiles(canvas, ctx, tileSize) {
            const { cols, rows } = getAtlasGrid();
            const tileWidth = Math.floor(tilesetImage.width / cols);
            const tileHeight = Math.floor(tilesetImage.height / rows);
            
            console.log(`Extracting atlas: ${cols}Ã—${rows} grid, tile size: ${tileWidth}Ã—${tileHeight}`);
            
            let validTileCount = 0;
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const sourceX = col * tileWidth;
                    const sourceY = row * tileHeight;
                    
                    // Skip if we're outside image bounds
                    if (sourceX + tileWidth > tilesetImage.width || sourceY + tileHeight > tilesetImage.height) {
                        continue;
                    }
                    
                    ctx.clearRect(0, 0, tileSize, tileSize);
                    
                    // Draw the tile, scaling to target tile size
                    ctx.drawImage(
                        tilesetImage,
                        sourceX, sourceY, tileWidth, tileHeight,
                        0, 0, tileSize, tileSize
                    );
                    
                    // Check if tile has meaningful content
                    if (isMeaningfulTile(canvas, ctx)) {
                        const tileData = canvas.toDataURL();
                        const tileIndex = tiles.length;
                        tiles.push(tileData);
                        
                        const classification = TileAnalyzer.classifyTile(canvas, tileIndex);
                        tileClassifications.set(tileIndex, classification);
                        selectedTiles.add(tileIndex);
                        validTileCount++;
                    }
                }
            }
            
            updateProcessingResult(`Atlas: ${validTileCount} tiles from ${cols}Ã—${rows} grid (${tileWidth}Ã—${tileHeight}px each)`, 'success');
        }

        function getAtlasGrid() {
            const gridSelect = document.getElementById('atlasGrid');
            const gridValue = gridSelect.value;
            
            if (gridValue === 'custom') {
                const cols = parseInt(document.getElementById('customCols').value);
                const rows = parseInt(document.getElementById('customRows').value);
                return { cols, rows };
            } else if (gridValue === 'auto') {
                return detectBestGrid();
            } else {
                const [cols, rows] = gridValue.split('x').map(n => parseInt(n));
                return { cols, rows };
            }
        }

        function detectBestGrid() {
            // Try common grid dimensions first (for NxN atlases)
            const commonGrids = [
                { cols: 16, rows: 16 },
                { cols: 8, rows: 8 },
                { cols: 4, rows: 4 },
                { cols: 2, rows: 2 },
                { cols: 32, rows: 32 },
                { cols: 12, rows: 12 },
                { cols: 6, rows: 6 }
            ];
            
            for (const grid of commonGrids) {
                const tileWidth = tilesetImage.width / grid.cols;
                const tileHeight = tilesetImage.height / grid.rows;
                
                // Check if this creates reasonable tile sizes (between 8 and 128 pixels)
                if (tileWidth >= 8 && tileWidth <= 128 && tileHeight >= 8 && tileHeight <= 128) {
                    // Check if the division is clean (no significant remainder)
                    const remainderX = tilesetImage.width % grid.cols;
                    const remainderY = tilesetImage.height % grid.rows;
                    
                    if (remainderX === 0 && remainderY === 0) {
                        console.log(`Auto-detected grid: ${grid.cols}Ã—${grid.rows} (tile size: ${tileWidth}Ã—${tileHeight})`);
                        return grid;
                    }
                }
            }
            
            // If no perfect match, try to find the best fit
            let bestGrid = { cols: 4, rows: 4 };
            let bestScore = 0;
            
            for (let cols = 2; cols <= 32; cols++) {
                for (let rows = 2; rows <= 32; rows++) {
                    const tileWidth = tilesetImage.width / cols;
                    const tileHeight = tilesetImage.height / rows;
                    
                    if (tileWidth >= 8 && tileWidth <= 128 && tileHeight >= 8 && tileHeight <= 128) {
                        const remainderX = tilesetImage.width % cols;
                        const remainderY = tilesetImage.height % rows;
                        const totalRemainder = remainderX + remainderY;
                        
                        // Score based on how clean the division is (lower remainder = better)
                        const score = 1000 - totalRemainder;
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestGrid = { cols, rows };
                        }
                    }
                }
            }
            
            console.log(`Best fit grid: ${bestGrid.cols}Ã—${bestGrid.rows}`);
            return bestGrid;
        }

        function isMeaningfulTile(canvas, ctx) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let totalAlpha = 0;
            let colorVariance = 0;
            let pixelCount = data.length / 4;
            
            for (let i = 0; i < data.length; i += 4) {
                totalAlpha += data[i + 3]; // Alpha channel
                
                const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                colorVariance += Math.abs(gray - 128);
            }
            
            const avgAlpha = totalAlpha / pixelCount;
            const avgVariance = colorVariance / pixelCount;
            
            // Consider tile meaningful if it's not completely transparent and has some variation
            return avgAlpha > 50 && avgVariance > 5;
        }

        function updateProcessingResult(message, type) {
            const resultDiv = document.getElementById('processingResult');
            const color = type === 'success' ? '#00ff88' : '#ff4444';
            resultDiv.innerHTML = `<div style="color: ${color};">${message}</div>`;
        }

        function displayTiles() {
            const preview = document.getElementById('tilesPreview');
            const section = document.getElementById('tilesSection');
            const paintSection = document.getElementById('paintSection');
            preview.innerHTML = '';
            
            tiles.forEach((tile, index) => {
                const div = document.createElement('div');
                div.className = 'tile-item';
                div.dataset.index = index;
                
                if (selectedTiles.has(index)) {
                    if (selectedTiles.size > 1) {
                        div.classList.add('multi-selected');
                    } else {
                        div.classList.add('selected');
                    }
                }
                
                const img = document.createElement('img');
                img.src = tile;
                
                const type = document.createElement('div');
                type.className = 'tile-type';
                type.textContent = tileClassifications.get(index);
                
                div.appendChild(img);
                div.appendChild(type);
                
                div.addEventListener('click', (e) => {
                    // Handle multi-select with Ctrl/Cmd key
                    if (e.ctrlKey || e.metaKey) {
                        if (selectedTiles.has(index)) {
                            selectedTiles.delete(index);
                            div.classList.remove('selected', 'multi-selected');
                        } else {
                            selectedTiles.add(index);
                            // Update all selected tiles' appearance
                            updateTileSelectionDisplay();
                        }
                    } else {
                        // Single select - clear others first
                        selectedTiles.clear();
                        document.querySelectorAll('.tile-item.selected, .tile-item.multi-selected').forEach(item => {
                            item.classList.remove('selected', 'multi-selected');
                        });
                        
                        selectedTiles.add(index);
                        div.classList.add('selected');
                    }
                    
                    updateTileStats();
                    updatePaintPreview();
                });
                
                preview.appendChild(div);
            });
            
            section.style.display = 'block';
            paintSection.style.display = 'block';
        }

        function updateTileSelectionDisplay() {
            document.querySelectorAll('.tile-item').forEach(item => {
                const index = parseInt(item.dataset.index);
                item.classList.remove('selected', 'multi-selected');
                
                if (selectedTiles.has(index)) {
                    if (selectedTiles.size > 1) {
                        item.classList.add('multi-selected');
                    } else {
                        item.classList.add('selected');
                    }
                }
            });
        }

        function updateTileStats() {
            const stats = document.getElementById('tileStats');
            const counts = { floor: 0, wall: 0, decoration: 0 };
            
            selectedTiles.forEach(index => {
                const type = tileClassifications.get(index);
                counts[type]++;
            });
            
            stats.innerHTML = `
                <div class="stat-item">
                    <span>Floors:</span>
                    <span class="stat-value">${counts.floor}</span>
                </div>
                <div class="stat-item">
                    <span>Walls:</span>
                    <span class="stat-value">${counts.wall}</span>
                </div>
                <div class="stat-item">
                    <span>Decorations:</span>
                    <span class="stat-value">${counts.decoration}</span>
                </div>
                <div class="stat-item">
                    <span>Total Selected:</span>
                    <span class="stat-value">${selectedTiles.size}</span>
                </div>
            `;
        }

        function updatePaintPreview() {
            const preview = document.getElementById('paintTilePreview');
            if (paintTileIndex !== null && tiles[paintTileIndex]) {
                preview.innerHTML = `<img src="${tiles[paintTileIndex]}" style="width: 100%; height: 100%; image-rendering: pixelated;">`;
            } else if (selectedTiles.size === 1) {
                const index = Array.from(selectedTiles)[0];
                preview.innerHTML = `<img src="${tiles[index]}" style="width: 100%; height: 100%; image-rendering: pixelated;">`;
                paintTileIndex = index;
            } else {
                preview.innerHTML = '<div style="color: #666; font-size: 10px; text-align: center; line-height: 44px;">Click to select</div>';
                paintTileIndex = null;
            }
        }

        function showTileSelector() {
            if (tiles.length === 0) return;
            
            const popup = document.getElementById('tileSelectorPopup');
            const overlay = document.getElementById('tileSelectorOverlay');
            const grid = document.getElementById('tileSelectorGrid');
            
            // Clear and populate the grid
            grid.innerHTML = '';
            
            tiles.forEach((tile, index) => {
                const div = document.createElement('div');
                div.className = 'tile-selector-item';
                if (paintTileIndex === index) {
                    div.classList.add('active');
                }
                
                const img = document.createElement('img');
                img.src = tile;
                div.appendChild(img);
                
                div.addEventListener('click', () => {
                    paintTileIndex = index;
                    updatePaintPreview();
                    closeTileSelector();
                });
                
                grid.appendChild(div);
            });
            
            overlay.style.display = 'block';
            popup.style.display = 'block';
        }

        function closeTileSelector() {
            document.getElementById('tileSelectorPopup').style.display = 'none';
            document.getElementById('tileSelectorOverlay').style.display = 'none';
        }

        function assignSelectedTiles() {
            const assignType = document.getElementById('tileAssignType').value;
            if (!assignType) return;
            
            // Initialize classification array if it doesn't exist
            if (!manualClassification[assignType]) {
                manualClassification[assignType] = [];
            }
            
            // Clear existing classification for these tiles
            Object.keys(manualClassification).forEach(type => {
                manualClassification[type] = manualClassification[type].filter(
                    index => !selectedTiles.includes(index)
                );
            });
            
            // Add tiles to new classification
            selectedTiles.forEach(tileIndex => {
                if (!manualClassification[assignType].includes(tileIndex)) {
                    manualClassification[assignType].push(tileIndex);
                }
            });
            
            // Clear selection and close overlay
            selectedTiles.clear();
            displayTiles();
            closeTileSelector();
            
            showStatus(`Assigned ${selectedTiles.size} tiles as ${assignType}`, 'success');
        }

        function generateMap() {
            console.log('generateMap called');
            
            if (!tilesetImage || tiles.length === 0) {
                console.log('No tileset or tiles available');
                showStatus('Please upload a tileset and extract tiles first', 'error');
                return;
            }

            if (selectedTiles.size === 0) {
                console.log('No tiles selected');
                showStatus('Please select some tiles to use for generation', 'error');
                return;
            }

            console.log('Selected tiles:', selectedTiles.size);
            console.log('Available tiles:', tiles.length);

            const mapSize = parseInt(document.getElementById('mapSize').value);
            const environmentType = document.getElementById('environmentType').value;
            
            console.log('Map size:', mapSize, 'Environment:', environmentType);
            
            // Group selected tiles by type
            const tilesByType = { floor: [], wall: [], decoration: [] };
            
            // Check if we have manual classifications
            const hasManualClassifications = Object.values(manualClassification).some(arr => arr.length > 0);
            
            if (hasManualClassifications) {
                console.log('Using manual classifications');
                // Use manual classification but only for selected tiles
                Object.keys(manualClassification).forEach(type => {
                    manualClassification[type].forEach(tileIndex => {
                        if (selectedTiles.has(tileIndex)) {
                            tilesByType[type].push(tileIndex);
                        }
                    });
                });
            } else {
                console.log('Using auto-classifications');
                // Use auto-classification from selected tiles only
                selectedTiles.forEach(index => {
                    const classification = tileClassifications.get(index) || 'floor';
                    tilesByType[classification].push(index);
                });
            }
            
            console.log('Tiles by type:', tilesByType);
            
            // Ensure we have at least some tiles
            const totalTiles = Object.values(tilesByType).reduce((sum, arr) => sum + arr.length, 0);
            if (totalTiles === 0) {
                console.log('No classified tiles available');
                showStatus('Please select some tiles or assign tile classifications', 'error');
                return;
            }
            
            try {
                // Generate intelligent map based on environment type
                console.log('Generating map...');
                const map = IntelligentMapGenerator.generate(mapSize, mapSize, tilesByType, environmentType);
                currentMap = map;
                
                console.log('Map generated, rendering...');
                renderMap();
                isMapGenerated = true;
                showStatus('Map generated successfully!', 'success');
                
                // Show paint section
                document.getElementById('paintSection').style.display = 'block';
                
            } catch (error) {
                console.error('Map generation error:', error);
                showStatus('Map generation failed: ' + error.message, 'error');
            }
        }

        function renderMap() {
            if (!currentMap || !tiles.length) return;
            
            mapCanvas.width = currentMap[0].length * tileSize;
            mapCanvas.height = currentMap.length * tileSize;
            
            mapCtx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
            
            for (let y = 0; y < currentMap.length; y++) {
                for (let x = 0; x < currentMap[y].length; x++) {
                    const tileIndex = currentMap[y][x];
                    if (tileIndex !== null && tiles[tileIndex]) {
                        mapCtx.drawImage(
                            tiles[tileIndex],
                            x * tileSize,
                            y * tileSize,
                            tileSize,
                            tileSize
                        );
                    }
                }
            }
            
            // Draw grid if opacity > 0
            if (gridOpacity > 0) {
                drawGrid();
            }
        }

        function updateGridOpacity() {
            const slider = document.getElementById('gridOpacity');
            const value = document.getElementById('gridOpacityValue');
            gridOpacity = parseInt(slider.value) / 100;
            value.textContent = slider.value + '%';
            
            // Redraw map if it exists
            if (isMapGenerated && currentMap) {
                renderMap();
            }
        }

        function drawGrid() {
            if (!mapCtx || !tileSize || !mapCanvas.width || !mapCanvas.height) return;
            
            mapCtx.save();
            mapCtx.globalAlpha = gridOpacity;
            mapCtx.strokeStyle = '#ffffff';
            mapCtx.lineWidth = 1;
            
            // Draw vertical lines
            for (let x = 0; x <= mapCanvas.width; x += tileSize) {
                mapCtx.beginPath();
                mapCtx.moveTo(x, 0);
                mapCtx.lineTo(x, mapCanvas.height);
                mapCtx.stroke();
            }
            
            // Draw horizontal lines
            for (let y = 0; y <= mapCanvas.height; y += tileSize) {
                mapCtx.beginPath();
                mapCtx.moveTo(0, y);
                mapCtx.lineTo(mapCanvas.width, y);
                mapCtx.stroke();
            }
            
            mapCtx.restore();
        }

        // Intelligent Map Generator with context-aware generation
        class IntelligentMapGenerator {
            static generate(width, height, tilesByType, environmentType) {
                const generator = new this(width, height, tilesByType, environmentType);
                return generator.generateMap();
            }
            
            constructor(width, height, tilesByType, environmentType) {
                this.width = width;
                this.height = height;
                this.tilesByType = tilesByType;
                this.environmentType = environmentType;
                this.map = Array(height).fill().map(() => Array(width).fill(null));
            }
            
            generateMap() {
                // Auto-detect environment if set to auto
                if (this.environmentType === 'auto') {
                    this.environmentType = this.detectEnvironment();
                }
                
                switch (this.environmentType) {
                    case 'dungeon':
                        return this.generateDungeon();
                    case 'tavern':
                        return this.generateTavern();
                    case 'castle':
                        return this.generateCastle();
                    case 'nature':
                        return this.generateNature();
                    case 'city':
                        return this.generateCity();
                    default:
                        return this.generateAbstract();
                }
            }
            
            detectEnvironment() {
                // Analyze tile colors and textures to detect environment type
                const analysis = this.analyzeTileContent();
                
                if (analysis.hasStone && analysis.hasDarkTones) return 'dungeon';
                if (analysis.hasWood && analysis.hasWarmTones) return 'tavern';
                if (analysis.hasGrass && analysis.hasNaturalTones) return 'nature';
                if (analysis.hasRoads && analysis.hasBuildings) return 'city';
                
                return 'abstract';
            }
            
            analyzeTileContent() {
                // This is a simplified analysis - in a real implementation,
                // you'd analyze the actual pixel data of tiles
                return {
                    hasStone: this.tilesByType.wall.length > 0,
                    hasDarkTones: true,
                    hasWood: this.tilesByType.decoration.length > 0,
                    hasWarmTones: true,
                    hasGrass: this.tilesByType.floor.length > 0,
                    hasNaturalTones: true,
                    hasRoads: this.tilesByType.floor.length > 0,
                    hasBuildings: this.tilesByType.wall.length > 0
                };
            }
            
            generateDungeon() {
                // Generate logical dungeon layout with rooms and corridors
                this.fillWithTile(this.getRandomTile('wall')); // Start with walls
                
                const rooms = this.generateRooms(3, 7); // 3-7 rooms
                
                // Create rooms
                rooms.forEach(room => {
                    this.carveRoom(room);
                });
                
                // Connect rooms with corridors
                this.connectRooms(rooms);
                
                // Add decorations to rooms
                this.addDungeonDecorations(rooms);
                
                return this.map;
            }
            
            generateTavern() {
                // Generate tavern layout with bar, tables, and furniture
                this.fillWithTile(this.getRandomTile('floor')); // Start with floor
                
                // Add walls around perimeter
                this.addPerimeterWalls();
                
                // Add tavern features
                this.addTavernBar();
                this.addTavernTables();
                this.addTavernDecorations();
                
                return this.map;
            }
            
            generateCastle() {
                // Generate castle with throne room, chambers, etc.
                this.fillWithTile(this.getRandomTile('wall')); // Start with walls
                
                const mainHall = { x: Math.floor(this.width * 0.3), y: Math.floor(this.height * 0.3), 
                                  width: Math.floor(this.width * 0.4), height: Math.floor(this.height * 0.4) };
                
                this.carveRoom(mainHall);
                this.addCastleFeatures(mainHall);
                
                return this.map;
            }
            
            generateNature() {
                // Generate natural environment with paths and organic features
                this.fillWithTile(this.getRandomTile('floor')); // Grass base
                
                this.addNaturalPaths();
                this.addNaturalFeatures();
                
                return this.map;
            }
            
            generateCity() {
                // Generate city with streets and buildings
                this.fillWithTile(this.getRandomTile('floor')); // Roads base
                
                this.addCityStreets();
                this.addCityBuildings();
                
                return this.map;
            }
            
            generateAbstract() {
                // Simple random generation
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const rand = Math.random();
                        if (rand < 0.6) {
                            this.map[y][x] = this.getRandomTile('floor');
                        } else if (rand < 0.85) {
                            this.map[y][x] = this.getRandomTile('wall');
                        } else {
                            this.map[y][x] = this.getRandomTile('decoration');
                        }
                    }
                }
                return this.map;
            }
            
            // Helper methods
            fillWithTile(tileIndex) {
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        this.map[y][x] = tileIndex;
                    }
                }
            }
            
            getRandomTile(type) {
                const tiles = this.tilesByType[type];
                if (!tiles || tiles.length === 0) {
                    // Fallback to any available tile
                    const allTiles = [...this.tilesByType.floor, ...this.tilesByType.wall, ...this.tilesByType.decoration];
                    return allTiles.length > 0 ? allTiles[Math.floor(Math.random() * allTiles.length)] : 0;
                }
                return tiles[Math.floor(Math.random() * tiles.length)];
            }
            
            generateRooms(minRooms, maxRooms) {
                const numRooms = Math.floor(Math.random() * (maxRooms - minRooms + 1)) + minRooms;
                const rooms = [];
                
                for (let i = 0; i < numRooms; i++) {
                    const room = this.generateRoom();
                    if (room && !this.roomOverlaps(room, rooms)) {
                        rooms.push(room);
                    }
                }
                
                return rooms;
            }
            
            generateRoom() {
                const minSize = 4;
                const maxSize = Math.min(this.width, this.height) / 3;
                
                const width = Math.floor(Math.random() * (maxSize - minSize)) + minSize;
                const height = Math.floor(Math.random() * (maxSize - minSize)) + minSize;
                
                const x = Math.floor(Math.random() * (this.width - width - 2)) + 1;
                const y = Math.floor(Math.random() * (this.height - height - 2)) + 1;
                
                return { x, y, width, height };
            }
            
            roomOverlaps(room, existingRooms) {
                return existingRooms.some(existing => 
                    room.x < existing.x + existing.width + 1 &&
                    room.x + room.width + 1 > existing.x &&
                    room.y < existing.y + existing.height + 1 &&
                    room.y + room.height + 1 > existing.y
                );
            }
            
            carveRoom(room) {
                for (let y = room.y; y < room.y + room.height; y++) {
                    for (let x = room.x; x < room.x + room.width; x++) {
                        if (this.isValidPosition(x, y)) {
                            this.map[y][x] = this.getRandomTile('floor');
                        }
                    }
                }
            }
            
            connectRooms(rooms) {
                for (let i = 0; i < rooms.length - 1; i++) {
                    const roomA = rooms[i];
                    const roomB = rooms[i + 1];
                    this.createCorridor(roomA, roomB);
                }
            }
            
            createCorridor(roomA, roomB) {
                const startX = Math.floor(roomA.x + roomA.width / 2);
                const startY = Math.floor(roomA.y + roomA.height / 2);
                const endX = Math.floor(roomB.x + roomB.width / 2);
                const endY = Math.floor(roomB.y + roomB.height / 2);
                
                // Create L-shaped corridor
                let currentX = startX;
                let currentY = startY;
                
                // Horizontal first
                while (currentX !== endX) {
                    if (this.isValidPosition(currentX, currentY)) {
                        this.map[currentY][currentX] = this.getRandomTile('floor');
                    }
                    currentX += currentX < endX ? 1 : -1;
                }
                
                // Then vertical
                while (currentY !== endY) {
                    if (this.isValidPosition(currentX, currentY)) {
                        this.map[currentY][currentX] = this.getRandomTile('floor');
                    }
                    currentY += currentY < endY ? 1 : -1;
                }
            }
            
            addDungeonDecorations(rooms) {
                rooms.forEach(room => {
                    // Add occasional decorative elements in corners or walls
                    if (Math.random() < 0.3) {
                        const x = room.x + Math.floor(Math.random() * room.width);
                        const y = room.y + Math.floor(Math.random() * room.height);
                        if (this.isValidPosition(x, y)) {
                            this.map[y][x] = this.getRandomTile('decoration');
                        }
                    }
                });
            }
            
            addPerimeterWalls() {
                // Top and bottom walls
                for (let x = 0; x < this.width; x++) {
                    this.map[0][x] = this.getRandomTile('wall');
                    this.map[this.height - 1][x] = this.getRandomTile('wall');
                }
                
                // Left and right walls
                for (let y = 0; y < this.height; y++) {
                    this.map[y][0] = this.getRandomTile('wall');
                    this.map[y][this.width - 1] = this.getRandomTile('wall');
                }
            }
            
            addTavernBar() {
                // Add bar along one wall
                const barY = Math.floor(this.height * 0.2);
                for (let x = 2; x < this.width - 2; x++) {
                    if (this.isValidPosition(x, barY)) {
                        this.map[barY][x] = this.getRandomTile('decoration');
                    }
                }
            }
            
            addTavernTables() {
                // Add scattered tables
                const numTables = Math.floor((this.width * this.height) / 50);
                for (let i = 0; i < numTables; i++) {
                    const x = Math.floor(Math.random() * (this.width - 4)) + 2;
                    const y = Math.floor(Math.random() * (this.height - 4)) + 2;
                    
                    if (this.isValidPosition(x, y) && Math.random() < 0.7) {
                        this.map[y][x] = this.getRandomTile('decoration');
                    }
                }
            }
            
            addTavernDecorations() {
                // Add random decorative elements
                for (let y = 1; y < this.height - 1; y++) {
                    for (let x = 1; x < this.width - 1; x++) {
                        if (Math.random() < 0.05) {
                            this.map[y][x] = this.getRandomTile('decoration');
                        }
                    }
                }
            }
            
            addCastleFeatures(mainHall) {
                // Add throne at the center back
                const throneX = Math.floor(mainHall.x + mainHall.width / 2);
                const throneY = mainHall.y + 1;
                if (this.isValidPosition(throneX, throneY)) {
                    this.map[throneY][throneX] = this.getRandomTile('decoration');
                }
                
                // Add pillars
                const pillarPositions = [
                    { x: mainHall.x + 2, y: mainHall.y + 2 },
                    { x: mainHall.x + mainHall.width - 3, y: mainHall.y + 2 },
                    { x: mainHall.x + 2, y: mainHall.y + mainHall.height - 3 },
                    { x: mainHall.x + mainHall.width - 3, y: mainHall.y + mainHall.height - 3 }
                ];
                
                pillarPositions.forEach(pos => {
                    if (this.isValidPosition(pos.x, pos.y)) {
                        this.map[pos.y][pos.x] = this.getRandomTile('decoration');
                    }
                });
            }
            
            addNaturalPaths() {
                // Create winding paths
                const numPaths = 2;
                for (let i = 0; i < numPaths; i++) {
                    this.createWindingPath();
                }
            }
            
            createWindingPath() {
                let x = Math.floor(Math.random() * this.width);
                let y = Math.floor(Math.random() * this.height);
                
                const pathLength = Math.floor(this.width * this.height * 0.1);
                
                for (let i = 0; i < pathLength; i++) {
                    if (this.isValidPosition(x, y)) {
                        this.map[y][x] = this.getRandomTile('decoration');
                    }
                    
                    // Random walk
                    const directions = [[-1,0], [1,0], [0,-1], [0,1]];
                    const dir = directions[Math.floor(Math.random() * directions.length)];
                    x = Math.max(0, Math.min(this.width - 1, x + dir[0]));
                    y = Math.max(0, Math.min(this.height - 1, y + dir[1]));
                }
            }
            
            addNaturalFeatures() {
                // Add random natural decorations (trees, rocks, etc.)
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        if (Math.random() < 0.1) {
                            this.map[y][x] = this.getRandomTile('decoration');
                        }
                    }
                }
            }
            
            addCityStreets() {
                // Add main streets
                const mainStreetX = Math.floor(this.width / 2);
                const mainStreetY = Math.floor(this.height / 2);
                
                // Vertical street
                for (let y = 0; y < this.height; y++) {
                    this.map[y][mainStreetX] = this.getRandomTile('floor');
                    if (mainStreetX > 0) this.map[y][mainStreetX - 1] = this.getRandomTile('floor');
                    if (mainStreetX < this.width - 1) this.map[y][mainStreetX + 1] = this.getRandomTile('floor');
                }
                
                // Horizontal street
                for (let x = 0; x < this.width; x++) {
                    this.map[mainStreetY][x] = this.getRandomTile('floor');
                    if (mainStreetY > 0) this.map[mainStreetY - 1][x] = this.getRandomTile('floor');
                    if (mainStreetY < this.height - 1) this.map[mainStreetY + 1][x] = this.getRandomTile('floor');
                }
            }
            
            addCityBuildings() {
                // Add building blocks in quadrants
                const quadrants = [
                    { x: 0, y: 0, width: Math.floor(this.width/2) - 2, height: Math.floor(this.height/2) - 2 },
                    { x: Math.floor(this.width/2) + 2, y: 0, width: Math.floor(this.width/2) - 2, height: Math.floor(this.height/2) - 2 },
                    { x: 0, y: Math.floor(this.height/2) + 2, width: Math.floor(this.width/2) - 2, height: Math.floor(this.height/2) - 2 },
                    { x: Math.floor(this.width/2) + 2, y: Math.floor(this.height/2) + 2, width: Math.floor(this.width/2) - 2, height: Math.floor(this.height/2) - 2 }
                ];
                
                quadrants.forEach(quad => {
                    if (quad.width > 0 && quad.height > 0) {
                        for (let y = quad.y; y < quad.y + quad.height; y++) {
                            for (let x = quad.x; x < quad.x + quad.width; x++) {
                                if (this.isValidPosition(x, y) && Math.random() < 0.7) {
                                    this.map[y][x] = this.getRandomTile('wall');
                                }
                            }
                        }
                    }
                });
            }
            
            isValidPosition(x, y) {
                return x >= 0 && x < this.width && y >= 0 && y < this.height;
            }
        }

        // Initialize the application
        function initApp() {
            try {
                // Verify all required elements exist
                const requiredElements = [
                    'uploadArea', 'fileInput', 'tilesPreview', 'tileStats',
                    'mapSize', 'tileSize', 'gridOpacity', 'gridOpacityValue',
                    'environmentType', 'outputCanvas'
                ];
                
                const missing = requiredElements.filter(id => !document.getElementById(id));
                if (missing.length > 0) {

                    console.error('Missing required elements:', missing);
                    showStatus('App initialization failed - missing elements', 'error');
                    return;
                }
                
                // Initialize grid opacity display
                updateGridOpacity();
                
                showStatus('Map Generator initialized successfully', 'success');
                console.log('Map Generator 2D - Ready');
                
            } catch (error) {
                console.error('App initialization error:', error);
                showStatus('App initialization failed', 'error');
            }
        }

        // Initialize when DOM is loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initApp);
        } else {
            initApp();
        }
    </script>
</body>
</html>