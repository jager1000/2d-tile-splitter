<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart 2D Map Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
            padding: 20px;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 2rem;
            background: linear-gradient(135deg, #00ff88 0%, #00aaff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .container {
            display: flex;
            flex: 1;
            gap: 20px;
            padding: 20px;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
        }

        .sidebar {
            width: 350px;
            background: #1a1a1a;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            max-height: calc(100vh - 120px);
        }

        .main-area {
            flex: 1;
            background: #1a1a1a;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .section {
            margin-bottom: 25px;
        }

        .section h3 {
            color: #00ff88;
            margin-bottom: 15px;
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .upload-area {
            border: 3px dashed #333;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #0a0a0a;
        }

        .upload-area:hover {
            border-color: #00ff88;
            background: #111;
        }

        .upload-area.dragover {
            border-color: #00aaff;
            background: #1a1a2e;
        }

        input[type="file"] {
            display: none;
        }

        .tiles-preview {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(48px, 1fr));
            gap: 8px;
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
            background: #0a0a0a;
            border-radius: 8px;
        }

        .tile-item {
            position: relative;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            overflow: hidden;
        }

        .tile-item:hover {
            transform: scale(1.1);
            border-color: #00ff88;
        }

        .tile-item.selected {
            border-color: #00aaff;
            box-shadow: 0 0 20px rgba(0, 170, 255, 0.5);
        }

        .tile-item.multi-selected {
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.4);
        }

        .tile-selector-item {
            position: relative;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            overflow: hidden;
        }

        .tile-selector-item:hover {
            transform: scale(1.05);
            border-color: #00ff88;
        }

        .tile-selector-item.active {
            border-color: #00aaff;
            box-shadow: 0 0 15px rgba(0, 170, 255, 0.5);
        }

        .tile-selector-item img {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        .tile-item img {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        .tile-type {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            font-size: 9px;
            padding: 2px;
            text-align: center;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            flex: 1;
            color: #aaa;
        }

        select, input[type="number"] {
            background: #0a0a0a;
            border: 2px solid #333;
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            min-width: 100px;
            transition: all 0.2s ease;
        }

        select:focus, input[type="number"]:focus {
            outline: none;
            border-color: #00ff88;
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #0a0a0a;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .checkbox-item:hover {
            background: #1a1a1a;
        }

        .checkbox-item input[type="checkbox"] {
            cursor: pointer;
        }

        .btn {
            background: linear-gradient(135deg, #00ff88 0%, #00aaff 100%);
            border: none;
            color: #000;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.9rem;
            width: 100%;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 255, 136, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: #333;
            color: #fff;
        }

        .btn-secondary:hover {
            background: #444;
            box-shadow: 0 8px 24px rgba(255, 255, 255, 0.1);
        }

        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #0a0a0a;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        #mapCanvas {
            border: 2px solid #333;
            image-rendering: pixelated;
            max-width: 100%;
            max-height: 100%;
        }

        .status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #1a1a1a;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            display: none;
            animation: slideIn 0.3s ease;
        }

        .status.success {
            border-left: 4px solid #00ff88;
        }

        .status.error {
            border-left: 4px solid #ff4444;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .tile-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background: #0a0a0a;
            border-radius: 6px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #aaa;
            font-size: 0.9rem;
        }

        .stat-value {
            color: #00ff88;
            font-weight: bold;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #0a0a0a;
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Smart 2D Map Generator</h1>
        <p style="color: #aaa;">AI-powered tile classification and intelligent map generation</p>
    </div>

    <div class="container">
        <div class="sidebar">
            <div class="section">
                <h3>1. Upload Tileset</h3>
                <div class="upload-area" id="uploadArea">
                    <p>ðŸŽ¨ Drop tileset image here</p>
                    <p style="margin-top: 10px; color: #666; font-size: 0.9rem;">or click to browse</p>
                </div>
                <input type="file" id="fileInput" accept="image/*">
                
                <div id="textureMode" style="display: none; margin-top: 15px;">
                    <div class="control-group">
                        <label>Texture Type:</label>
                        <select id="textureModeSelect" onchange="reprocessTexture()">
                            <option value="single">Single Texture</option>
                            <option value="atlas" selected>Tile Atlas</option>
                        </select>
                    </div>
                    <div id="atlasControls" style="display: none; margin-top: 10px;">
                        <div class="control-group">
                            <label>Atlas Grid:</label>
                            <select id="atlasGrid" onchange="reprocessTexture()">
                                <option value="auto">Auto-detect Grid</option>
                                <option value="2x2">2Ã—2</option>
                                <option value="4x4">4Ã—4</option>
                                <option value="8x8">8Ã—8</option>
                                <option value="16x16">16Ã—16</option>
                                <option value="custom">Custom</option>
                            </select>
                        </div>
                        <div id="customGrid" style="display: none;">
                            <div class="control-group">
                                <label>Columns:</label>
                                <input type="number" id="customCols" value="4" min="1" max="32" onchange="reprocessTexture()">
                            </div>
                            <div class="control-group">
                                <label>Rows:</label>
                                <input type="number" id="customRows" value="4" min="1" max="32" onchange="reprocessTexture()">
                            </div>
                        </div>
                    </div>
                    <div id="processingResult" style="margin-top: 8px; padding: 8px; background: #0a0a0a; border-radius: 4px; font-size: 0.85rem;"></div>
                </div>
            </div>

            <div class="section" id="tilesSection" style="display: none;">
                <h3>2. Classify Tiles</h3>
                <p style="color: #aaa; font-size: 0.9rem; margin-bottom: 15px;">Select tiles and assign them to categories. Multiple selection with Ctrl+Click.</p>
                
                <div class="tile-classification-controls" style="margin-bottom: 15px;">
                    <div class="control-group">
                        <label>Selected tiles are:</label>
                        <select id="tileAssignType">
                            <option value="floor">Floors (base layer)</option>
                            <option value="wall">Walls (obstacles)</option>
                            <option value="decoration">Decorations (overlays)</option>
                        </select>
                        <button class="btn btn-secondary" onclick="assignSelectedTiles()" style="width: auto; padding: 8px 16px; font-size: 0.8rem;">Assign</button>
                    </div>
                </div>
                
                <div class="tiles-preview" id="tilesPreview"></div>
                <div class="tile-stats" id="tileStats"></div>
            </div>

            <div class="section">
                <h3>3. Map Settings</h3>
                <div class="controls">
                    <div class="control-group">
                        <label>Map Size:</label>
                        <select id="mapSize">
                            <option value="16">16x16</option>
                            <option value="32" selected>32x32</option>
                            <option value="64">64x64</option>
                            <option value="128">128x128</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Tile Size:</label>
                        <input type="number" id="tileSize" value="32" min="8" max="128">
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>4. Generation Options</h3>
                <div class="checkbox-group" id="assetTypes">
                    <div class="checkbox-item">
                        <input type="checkbox" id="useFloors" checked>
                        <label for="useFloors">Floors</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="useWalls" checked>
                        <label for="useWalls">Walls</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="useDecorations" checked>
                        <label for="useDecorations">Decorations</label>
                    </div>
                </div>
                
                <div class="control-group" style="margin-top: 15px;">
                    <label>Environment Type:</label>
                    <select id="environmentType">
                        <option value="auto">Auto-detect</option>
                        <option value="nature">Nature (grass, water, trees)</option>
                        <option value="dungeon">Dungeon (stone, corridors)</option>
                        <option value="city">City (roads, buildings)</option>
                        <option value="abstract">Abstract/Mixed</option>
                    </select>
                </div>
            </div>

            <button class="btn" onclick="generateMap()">Generate Map</button>
            <button class="btn btn-secondary" onclick="exportMap()" style="margin-top: 10px;">Export as PNG</button>
            
            <div class="section" id="paintSection" style="display: none; margin-top: 20px;">
                <h3>5. Paint Mode</h3>
                <p style="color: #aaa; font-size: 0.9rem; margin-bottom: 10px;">Click tile preview to select paint tile, then drag on map to paint.</p>
                <div id="paintTilePreview" style="width: 48px; height: 48px; border: 2px solid #333; border-radius: 4px; background: #0a0a0a; margin-bottom: 10px; cursor: pointer;" onclick="showTileSelector()"></div>
                <button class="btn btn-secondary" onclick="togglePaintMode()" id="paintModeBtn">Enable Paint Mode</button>
                
                <!-- Tile Selector Popup -->
                <div id="tileSelectorPopup" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; border: 2px solid #333; border-radius: 8px; padding: 20px; z-index: 1000; max-width: 500px; max-height: 400px; overflow-y: auto;">
                    <h4 style="color: #00ff88; margin-bottom: 15px;">Select Paint Tile</h4>
                    <div id="tileSelectorGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(48px, 1fr)); gap: 8px; margin-bottom: 15px;"></div>
                    <button class="btn btn-secondary" onclick="closeTileSelector()" style="width: 100%;">Close</button>
                </div>
                <div id="tileSelectorOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;" onclick="closeTileSelector()"></div>
            </div>
        </div>

        <div class="main-area">
            <div class="canvas-container">
                <canvas id="outputCanvas" style="border: 2px solid #333; image-rendering: pixelated; max-width: 100%; max-height: 100%;"></canvas>
            </div>
        </div>
    </div>

    <div class="status" id="status"></div>

    <script>
        let tilesetImage = null;
        let tiles = [];
        let selectedTiles = new Set();
        let tileClassifications = new Map();
        let currentMap = null;
        let paintMode = false;
        let paintTileIndex = null;
        let tileStates = {}; // Track tile selection states
        let manualClassification = { floor: [], wall: [], decoration: [] }; // Manual tile assignments

        // Smart tile analysis using visual features
        class TileAnalyzer {
            static analyzeTexture(imageData) {
                const data = imageData.data;
                let edges = 0;
                let variance = 0;
                let avgBrightness = 0;
                
                for (let i = 0; i < data.length; i += 4) {
                    const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                    avgBrightness += brightness;
                    
                    if (i > 0 && Math.abs(brightness - (data[i-4] + data[i-3] + data[i-2]) / 3) > 30) {
                        edges++;
                    }
                }
                
                avgBrightness /= (data.length / 4);
                
                let colorSum = [0, 0, 0];
                for (let i = 0; i < data.length; i += 4) {
                    colorSum[0] += data[i];
                    colorSum[1] += data[i+1];
                    colorSum[2] += data[i+2];
                }
                
                const avgColor = colorSum.map(c => c / (data.length / 4));
                for (let i = 0; i < data.length; i += 4) {
                    variance += Math.abs(data[i] - avgColor[0]) + 
                               Math.abs(data[i+1] - avgColor[1]) + 
                               Math.abs(data[i+2] - avgColor[2]);
                }
                variance /= (data.length / 4);
                
                return { edges, variance, avgBrightness };
            }

            static classifyTile(canvas, index) {
                try {
                    const ctx = canvas.getContext('2d');
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const features = this.analyzeTexture(imageData);
                    const dominantColor = this.getDominantColor(imageData);
                    
                    if (features.edges < 50 && features.variance < 30) {
                        return this.classifyByColor(dominantColor, 'floor');
                    } else if (features.edges > 200 || features.avgBrightness < 50) {
                        return this.classifyByColor(dominantColor, 'wall');
                    } else if (features.variance > 100) {
                        return 'decoration';
                    } else {
                        return this.classifyByColor(dominantColor, 'floor');
                    }
                } catch (error) {
                    console.warn('Tile classification error:', error);
                    return 'floor';
                }
            }

            static getDominantColor(imageData) {
                const data = imageData.data;
                let r = 0, g = 0, b = 0;
                const pixelCount = data.length / 4;
                
                for (let i = 0; i < data.length; i += 4) {
                    r += data[i];
                    g += data[i + 1];
                    b += data[i + 2];
                }
                
                return {
                    r: r / pixelCount,
                    g: g / pixelCount,
                    b: b / pixelCount
                };
            }

            static classifyByColor(color, defaultType) {
                const { r, g, b } = color;
                const brightness = (r + g + b) / 3;
                
                if (g > r && g > b && g > 100) return 'floor'; // Green
                if (r > 100 && g > 80 && b < 80) return 'floor'; // Brown/earthy
                if (brightness < 60 || (Math.abs(r - g) < 20 && Math.abs(g - b) < 20 && brightness < 120)) return 'wall'; // Dark or gray
                
                return defaultType;
            }
        }

        // Map generation with intelligent placement
        class MapGenerator {
            static generate(width, height, tilesByType, environmentType) {
                const map = Array(height).fill(null).map(() => Array(width).fill(null));
                return this.generateByEnvironment(map, tilesByType, environmentType);
            }

            static generateByEnvironment(map, tilesByType, environmentType) {
                switch(environmentType) {
                    case 'nature':
                        return this.generateNature(map, tilesByType);
                    case 'dungeon':
                        return this.generateDungeon(map, tilesByType);
                    case 'city':
                        return this.generateCity(map, tilesByType);
                    case 'auto':
                        return this.generateAuto(map, tilesByType);
                    case 'abstract':
                    default:
                        return this.generateTopDown(map, tilesByType);
                }
            }

            static generateNature(map, tilesByType) {
                const height = map.length;
                const width = map[0].length;
                
                // Base layer: mostly grass/ground
                const floors = tilesByType.floor || [];
                if (floors.length > 0) {
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            map[y][x] = floors[Math.floor(Math.random() * floors.length)];
                        }
                    }
                }
                
                // Water features (walls can be water)
                const walls = tilesByType.wall || [];
                if (walls.length > 0) {
                    // Create a river or pond
                    if (Math.random() > 0.5) {
                        // River
                        const riverY = Math.floor(height * (0.3 + Math.random() * 0.4));
                        for (let x = 0; x < width; x++) {
                            map[riverY][x] = walls[Math.floor(Math.random() * walls.length)];
                            if (Math.random() > 0.7 && riverY + 1 < height) {
                                map[riverY + 1][x] = walls[Math.floor(Math.random() * walls.length)];
                            }
                        }
                    } else {
                        // Pond
                        const centerX = Math.floor(width / 2);
                        const centerY = Math.floor(height / 2);
                        const radius = Math.floor(Math.min(width, height) * 0.15);
                        
                        for (let y = centerY - radius; y <= centerY + radius; y++) {
                            for (let x = centerX - radius; x <= centerX + radius; x++) {
                                if (x >= 0 && x < width && y >= 0 && y < height) {
                                    const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                                    if (dist <= radius) {
                                        map[y][x] = walls[Math.floor(Math.random() * walls.length)];
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Trees and rocks (decorations)
                const decorations = tilesByType.decoration || [];
                if (decorations.length > 0) {
                    // Scattered trees/rocks
                    const numClusters = Math.floor(Math.random() * 4) + 3;
                    for (let i = 0; i < numClusters; i++) {
                        const clusterX = Math.floor(Math.random() * width);
                        const clusterY = Math.floor(Math.random() * height);
                        const clusterSize = Math.floor(Math.random() * 5) + 2;
                        
                        for (let j = 0; j < clusterSize; j++) {
                            const x = clusterX + Math.floor(Math.random() * 6) - 3;
                            const y = clusterY + Math.floor(Math.random() * 6) - 3;
                            
                            if (x >= 0 && x < width && y >= 0 && y < height) {
                                map[y][x] = decorations[Math.floor(Math.random() * decorations.length)];
                            }
                        }
                    }
                }
                
                return map;
            }

            static generateDungeon(map, tilesByType) {
                const height = map.length;
                const width = map[0].length;
                
                // Start with walls everywhere
                const walls = tilesByType.wall || [];
                if (walls.length > 0) {
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            map[y][x] = walls[Math.floor(Math.random() * walls.length)];
                        }
                    }
                }
                
                // Carve out rooms and corridors with floors
                const floors = tilesByType.floor || [];
                if (floors.length > 0) {
                    // Generate rooms
                    const numRooms = Math.floor(Math.random() * 4) + 3;
                    const rooms = [];
                    
                    for (let i = 0; i < numRooms; i++) {
                        const roomWidth = Math.floor(Math.random() * 8) + 4;
                        const roomHeight = Math.floor(Math.random() * 8) + 4;
                        const roomX = Math.floor(Math.random() * (width - roomWidth - 2)) + 1;
                        const roomY = Math.floor(Math.random() * (height - roomHeight - 2)) + 1;
                        
                        rooms.push({ x: roomX, y: roomY, width: roomWidth, height: roomHeight });
                        
                        // Fill room with floor
                        for (let y = roomY; y < roomY + roomHeight; y++) {
                            for (let x = roomX; x < roomX + roomWidth; x++) {
                                map[y][x] = floors[Math.floor(Math.random() * floors.length)];
                            }
                        }
                    }
                    
                    // Connect rooms with corridors
                    for (let i = 0; i < rooms.length - 1; i++) {
                        const room1 = rooms[i];
                        const room2 = rooms[i + 1];
                        
                        const x1 = room1.x + Math.floor(room1.width / 2);
                        const y1 = room1.y + Math.floor(room1.height / 2);
                        const x2 = room2.x + Math.floor(room2.width / 2);
                        const y2 = room2.y + Math.floor(room2.height / 2);
                        
                        // Horizontal corridor
                        for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {
                            map[y1][x] = floors[Math.floor(Math.random() * floors.length)];
                        }
                        
                        // Vertical corridor
                        for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {
                            map[y][x2] = floors[Math.floor(Math.random() * floors.length)];
                        }
                    }
                }
                
                // Add decorations (torches, furniture, etc.)
                const decorations = tilesByType.decoration || [];
                if (decorations.length > 0) {
                    for (let y = 1; y < height - 1; y++) {
                        for (let x = 1; x < width - 1; x++) {
                            // Place decorations on floor tiles near walls
                            if (!walls.includes(map[y][x]) && Math.random() < 0.05) {
                                let nearWall = false;
                                for (let dy = -1; dy <= 1; dy++) {
                                    for (let dx = -1; dx <= 1; dx++) {
                                        if (y + dy >= 0 && y + dy < height && x + dx >= 0 && x + dx < width && 
                                            walls.includes(map[y + dy][x + dx])) {
                                            nearWall = true;
                                            break;
                                        }
                                    }
                                    if (nearWall) break;
                                }
                                if (nearWall) {
                                    map[y][x] = decorations[Math.floor(Math.random() * decorations.length)];
                                }
                            }
                        }
                    }
                }
                
                return map;
            }

            static generateCity(map, tilesByType) {
                const height = map.length;
                const width = map[0].length;
                
                // Base with road/ground material
                const floors = tilesByType.floor || [];
                if (floors.length > 0) {
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            map[y][x] = floors[Math.floor(Math.random() * floors.length)];
                        }
                    }
                }
                
                // Create a grid of roads
                const walls = tilesByType.wall || [];
                if (walls.length > 0) {
                    // Vertical roads
                    for (let x = 8; x < width; x += 12) {
                        for (let y = 0; y < height; y++) {
                            map[y][x] = walls[Math.floor(Math.random() * walls.length)];
                            if (x + 1 < width) {
                                map[y][x + 1] = walls[Math.floor(Math.random() * walls.length)];
                            }
                        }
                    }
                    
                    // Horizontal roads
                    for (let y = 8; y < height; y += 12) {
                        for (let x = 0; x < width; x++) {
                            map[y][x] = walls[Math.floor(Math.random() * walls.length)];
                            if (y + 1 < height) {
                                map[y + 1][x] = walls[Math.floor(Math.random() * walls.length)];
                            }
                        }
                    }
                }
                
                // Add buildings/decorations
                const decorations = tilesByType.decoration || [];
                if (decorations.length > 0) {
                    // Fill blocks with buildings
                    for (let blockY = 0; blockY < height; blockY += 12) {
                        for (let blockX = 0; blockX < width; blockX += 12) {
                            if (Math.random() > 0.3) { // 70% chance of building
                                for (let y = blockY + 1; y < Math.min(blockY + 7, height); y++) {
                                    for (let x = blockX + 1; x < Math.min(blockX + 7, width); x++) {
                                        if (Math.random() > 0.2) {
                                            map[y][x] = decorations[Math.floor(Math.random() * decorations.length)];
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                return map;
            }

            static generateAuto(map, tilesByType) {
                // Simple heuristic based on tile types available
                const hasWater = tilesByType.wall && tilesByType.wall.length > 0;
                const hasVegetation = tilesByType.decoration && tilesByType.decoration.length > 0;
                
                if (hasWater && hasVegetation) {
                    return this.generateNature(map, tilesByType);
                } else if (tilesByType.wall && tilesByType.wall.length > tilesByType.floor.length) {
                    return this.generateDungeon(map, tilesByType);
                } else {
                    return this.generateTopDown(map, tilesByType);
                }
            }

            static generateTopDown(map, tilesByType) {
                const height = map.length;
                const width = map[0].length;
                
                // Fill with floor tiles
                const floors = tilesByType.floor || [];
                if (floors.length > 0) {
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            map[y][x] = floors[Math.floor(Math.random() * floors.length)];
                        }
                    }
                }
                
                // Add walls around edges
                const walls = tilesByType.wall || [];
                if (walls.length > 0) {
                    for (let x = 0; x < width; x++) {
                        map[0][x] = walls[Math.floor(Math.random() * walls.length)];
                        map[height-1][x] = walls[Math.floor(Math.random() * walls.length)];
                    }
                    for (let y = 0; y < height; y++) {
                        map[y][0] = walls[Math.floor(Math.random() * walls.length)];
                        map[y][width-1] = walls[Math.floor(Math.random() * walls.length)];
                    }
                }
                
                // Add decorations
                const decorations = tilesByType.decoration || [];
                if (decorations.length > 0) {
                    const numDecorations = Math.floor((width * height) * 0.1);
                    for (let i = 0; i < numDecorations; i++) {
                        const x = Math.floor(Math.random() * width);
                        const y = Math.floor(Math.random() * height);
                        map[y][x] = decorations[Math.floor(Math.random() * decorations.length)];
                    }
                }
                
                return map;
            }
        }

        // UI handlers
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFile(e.dataTransfer.files[0]);
        });

        fileInput.addEventListener('change', (e) => {
            handleFile(e.target.files[0]);
        });

        function handleFile(file) {
            if (!file || !file.type.startsWith('image/')) {
                showStatus('Please upload an image file', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                tilesetImage = new Image();
                tilesetImage.onload = () => {
                    document.getElementById('textureMode').style.display = 'block';
                    updateModeVisibility();
                    extractTiles();
                    showStatus('Tileset loaded successfully!', 'success');
                };
                tilesetImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function updateModeVisibility() {
            const mode = document.getElementById('textureModeSelect').value;
            const atlasControls = document.getElementById('atlasControls');
            const customGrid = document.getElementById('customGrid');
            
            if (mode === 'atlas') {
                atlasControls.style.display = 'block';
                const gridValue = document.getElementById('atlasGrid').value;
                customGrid.style.display = gridValue === 'custom' ? 'block' : 'none';
            } else {
                atlasControls.style.display = 'none';
                customGrid.style.display = 'none';
            }
        }

        function reprocessTexture() {
            if (tilesetImage) {
                updateModeVisibility();
                extractTiles();
                showStatus('Texture reprocessed!', 'success');
            }
        }

        // Event listeners
        document.getElementById('tileSize').addEventListener('change', () => {
            if (tilesetImage) {
                reprocessTexture();
            }
        });

        document.getElementById('atlasGrid').addEventListener('change', () => {
            updateModeVisibility();
            if (tilesetImage) {
                reprocessTexture();
            }
        });

        function extractTiles() {
            const tileSize = parseInt(document.getElementById('tileSize').value);
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            tiles = [];
            tileClassifications.clear();
            selectedTiles.clear();
            
            const modeSelect = document.getElementById('textureModeSelect');
            const mode = modeSelect.value;
            
            canvas.width = tileSize;
            canvas.height = tileSize;
            
            if (mode === 'single') {
                extractSingleTexture(canvas, ctx, tileSize);
            } else {
                extractAtlasTiles(canvas, ctx, tileSize);
            }
            
            displayTiles();
            updateTileStats();
        }

        function extractSingleTexture(canvas, ctx, tileSize) {
            // Scale image to fit tile size while maintaining aspect ratio
            const scale = Math.min(tileSize / tilesetImage.width, tileSize / tilesetImage.height);
            const scaledWidth = tilesetImage.width * scale;
            const scaledHeight = tilesetImage.height * scale;
            const offsetX = (tileSize - scaledWidth) / 2;
            const offsetY = (tileSize - scaledHeight) / 2;
            
            ctx.clearRect(0, 0, tileSize, tileSize);
            ctx.drawImage(
                tilesetImage,
                0, 0, tilesetImage.width, tilesetImage.height,
                offsetX, offsetY, scaledWidth, scaledHeight
            );
            
            const tileData = canvas.toDataURL();
            tiles.push(tileData);
            
            const classification = TileAnalyzer.classifyTile(canvas, 0);
            tileClassifications.set(0, classification);
            selectedTiles.add(0);
            
            updateProcessingResult(`Single texture processed (${tilesetImage.width}Ã—${tilesetImage.height}px)`, 'success');
        }

        function extractAtlasTiles(canvas, ctx, tileSize) {
            const { cols, rows } = getAtlasGrid();
            const tileWidth = Math.floor(tilesetImage.width / cols);
            const tileHeight = Math.floor(tilesetImage.height / rows);
            
            console.log(`Extracting atlas: ${cols}Ã—${rows} grid, tile size: ${tileWidth}Ã—${tileHeight}`);
            
            let validTileCount = 0;
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const sourceX = col * tileWidth;
                    const sourceY = row * tileHeight;
                    
                    // Skip if we're outside image bounds
                    if (sourceX + tileWidth > tilesetImage.width || sourceY + tileHeight > tilesetImage.height) {
                        continue;
                    }
                    
                    ctx.clearRect(0, 0, tileSize, tileSize);
                    
                    // Draw the tile, scaling to target tile size
                    ctx.drawImage(
                        tilesetImage,
                        sourceX, sourceY, tileWidth, tileHeight,
                        0, 0, tileSize, tileSize
                    );
                    
                    // Check if tile has meaningful content
                    if (isMeaningfulTile(canvas, ctx)) {
                        const tileData = canvas.toDataURL();
                        const tileIndex = tiles.length;
                        tiles.push(tileData);
                        
                        const classification = TileAnalyzer.classifyTile(canvas, tileIndex);
                        tileClassifications.set(tileIndex, classification);
                        selectedTiles.add(tileIndex);
                        validTileCount++;
                    }
                }
            }
            
            updateProcessingResult(`Atlas: ${validTileCount} tiles from ${cols}Ã—${rows} grid (${tileWidth}Ã—${tileHeight}px each)`, 'success');
        }

        function getAtlasGrid() {
            const gridSelect = document.getElementById('atlasGrid');
            const gridValue = gridSelect.value;
            
            if (gridValue === 'custom') {
                const cols = parseInt(document.getElementById('customCols').value);
                const rows = parseInt(document.getElementById('customRows').value);
                return { cols, rows };
            } else if (gridValue === 'auto') {
                return detectBestGrid();
            } else {
                const [cols, rows] = gridValue.split('x').map(n => parseInt(n));
                return { cols, rows };
            }
        }

        function detectBestGrid() {
            // Try common grid dimensions first (for NxN atlases)
            const commonGrids = [
                { cols: 16, rows: 16 },
                { cols: 8, rows: 8 },
                { cols: 4, rows: 4 },
                { cols: 2, rows: 2 },
                { cols: 32, rows: 32 },
                { cols: 12, rows: 12 },
                { cols: 6, rows: 6 }
            ];
            
            for (const grid of commonGrids) {
                const tileWidth = tilesetImage.width / grid.cols;
                const tileHeight = tilesetImage.height / grid.rows;
                
                // Check if this creates reasonable tile sizes (between 8 and 128 pixels)
                if (tileWidth >= 8 && tileWidth <= 128 && tileHeight >= 8 && tileHeight <= 128) {
                    // Check if the division is clean (no significant remainder)
                    const remainderX = tilesetImage.width % grid.cols;
                    const remainderY = tilesetImage.height % grid.rows;
                    
                    if (remainderX === 0 && remainderY === 0) {
                        console.log(`Auto-detected grid: ${grid.cols}Ã—${grid.rows} (tile size: ${tileWidth}Ã—${tileHeight})`);
                        return grid;
                    }
                }
            }
            
            // If no perfect match, try to find the best fit
            let bestGrid = { cols: 4, rows: 4 };
            let bestScore = 0;
            
            for (let cols = 2; cols <= 32; cols++) {
                for (let rows = 2; rows <= 32; rows++) {
                    const tileWidth = tilesetImage.width / cols;
                    const tileHeight = tilesetImage.height / rows;
                    
                    if (tileWidth >= 8 && tileWidth <= 128 && tileHeight >= 8 && tileHeight <= 128) {
                        const remainderX = tilesetImage.width % cols;
                        const remainderY = tilesetImage.height % rows;
                        const totalRemainder = remainderX + remainderY;
                        
                        // Score based on how clean the division is (lower remainder = better)
                        const score = 1000 - totalRemainder;
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestGrid = { cols, rows };
                        }
                    }
                }
            }
            
            console.log(`Best fit grid: ${bestGrid.cols}Ã—${bestGrid.rows}`);
            return bestGrid;
        }

        function isMeaningfulTile(canvas, ctx) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let totalAlpha = 0;
            let colorVariance = 0;
            let pixelCount = data.length / 4;
            
            for (let i = 0; i < data.length; i += 4) {
                totalAlpha += data[i + 3]; // Alpha channel
                
                const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                colorVariance += Math.abs(gray - 128);
            }
            
            const avgAlpha = totalAlpha / pixelCount;
            const avgVariance = colorVariance / pixelCount;
            
            // Consider tile meaningful if it's not completely transparent and has some variation
            return avgAlpha > 50 && avgVariance > 5;
        }

        function updateProcessingResult(message, type) {
            const resultDiv = document.getElementById('processingResult');
            const color = type === 'success' ? '#00ff88' : '#ff4444';
            resultDiv.innerHTML = `<div style="color: ${color};">${message}</div>`;
        }

        function displayTiles() {
            const preview = document.getElementById('tilesPreview');
            const section = document.getElementById('tilesSection');
            const paintSection = document.getElementById('paintSection');
            preview.innerHTML = '';
            
            tiles.forEach((tile, index) => {
                const div = document.createElement('div');
                div.className = 'tile-item';
                div.dataset.index = index;
                
                if (selectedTiles.has(index)) {
                    if (selectedTiles.size > 1) {
                        div.classList.add('multi-selected');
                    } else {
                        div.classList.add('selected');
                    }
                }
                
                const img = document.createElement('img');
                img.src = tile;
                
                const type = document.createElement('div');
                type.className = 'tile-type';
                type.textContent = tileClassifications.get(index);
                
                div.appendChild(img);
                div.appendChild(type);
                
                div.addEventListener('click', (e) => {
                    // Handle multi-select with Ctrl/Cmd key
                    if (e.ctrlKey || e.metaKey) {
                        if (selectedTiles.has(index)) {
                            selectedTiles.delete(index);
                            div.classList.remove('selected', 'multi-selected');
                        } else {
                            selectedTiles.add(index);
                            // Update all selected tiles' appearance
                            updateTileSelectionDisplay();
                        }
                    } else {
                        // Single select - clear others first
                        selectedTiles.clear();
                        document.querySelectorAll('.tile-item.selected, .tile-item.multi-selected').forEach(item => {
                            item.classList.remove('selected', 'multi-selected');
                        });
                        
                        selectedTiles.add(index);
                        div.classList.add('selected');
                    }
                    
                    updateTileStats();
                    updatePaintPreview();
                });
                
                preview.appendChild(div);
            });
            
            section.style.display = 'block';
            paintSection.style.display = 'block';
        }

        function updateTileSelectionDisplay() {
            document.querySelectorAll('.tile-item').forEach(item => {
                const index = parseInt(item.dataset.index);
                item.classList.remove('selected', 'multi-selected');
                
                if (selectedTiles.has(index)) {
                    if (selectedTiles.size > 1) {
                        item.classList.add('multi-selected');
                    } else {
                        item.classList.add('selected');
                    }
                }
            });
        }

        function updateTileStats() {
            const stats = document.getElementById('tileStats');
            const counts = { floor: 0, wall: 0, decoration: 0 };
            
            selectedTiles.forEach(index => {
                const type = tileClassifications.get(index);
                counts[type]++;
            });
            
            stats.innerHTML = `
                <div class="stat-item">
                    <span>Floors:</span>
                    <span class="stat-value">${counts.floor}</span>
                </div>
                <div class="stat-item">
                    <span>Walls:</span>
                    <span class="stat-value">${counts.wall}</span>
                </div>
                <div class="stat-item">
                    <span>Decorations:</span>
                    <span class="stat-value">${counts.decoration}</span>
                </div>
                <div class="stat-item">
                    <span>Total Selected:</span>
                    <span class="stat-value">${selectedTiles.size}</span>
                </div>
            `;
        }

        function updatePaintPreview() {
            const preview = document.getElementById('paintTilePreview');
            if (paintTileIndex !== null && tiles[paintTileIndex]) {
                preview.innerHTML = `<img src="${tiles[paintTileIndex]}" style="width: 100%; height: 100%; image-rendering: pixelated;">`;
            } else if (selectedTiles.size === 1) {
                const index = Array.from(selectedTiles)[0];
                preview.innerHTML = `<img src="${tiles[index]}" style="width: 100%; height: 100%; image-rendering: pixelated;">`;
                paintTileIndex = index;
            } else {
                preview.innerHTML = '<div style="color: #666; font-size: 10px; text-align: center; line-height: 44px;">Click to select</div>';
                paintTileIndex = null;
            }
        }

        function showTileSelector() {
            if (tiles.length === 0) return;
            
            const popup = document.getElementById('tileSelectorPopup');
            const overlay = document.getElementById('tileSelectorOverlay');
            const grid = document.getElementById('tileSelectorGrid');
            
            // Clear and populate the grid
            grid.innerHTML = '';
            
            tiles.forEach((tile, index) => {
                const div = document.createElement('div');
                div.className = 'tile-selector-item';
                if (paintTileIndex === index) {
                    div.classList.add('active');
                }
                
                const img = document.createElement('img');
                img.src = tile;
                div.appendChild(img);
                
                div.addEventListener('click', () => {
                    paintTileIndex = index;
                    updatePaintPreview();
                    closeTileSelector();
                });
                
                grid.appendChild(div);
            });
            
            overlay.style.display = 'block';
            popup.style.display = 'block';
        }

        function closeTileSelector() {
            document.getElementById('tileSelectorPopup').style.display = 'none';
            document.getElementById('tileSelectorOverlay').style.display = 'none';
        }

        function assignSelectedTiles() {
            const assignType = document.getElementById('tileAssignType').value;
            if (!assignType) return;
            
            if (selectedTiles.size === 0) {
                alert('Please select at least one tile first (use Ctrl+Click for multiple selection)');
                return;
            }
            
            // Remove tiles from their current manual categories
            Object.keys(manualClassification).forEach(type => {
                manualClassification[type] = manualClassification[type].filter(index => 
                    !selectedTiles.has(index)
                );
            });
            
            // Add selected tiles to new category
            selectedTiles.forEach(index => {
                manualClassification[assignType].push(index);
                // Update the visual classification display
                tileClassifications.set(index, assignType);
            });
            
            // Update the tile display to show new classifications
            displayTiles();
            updateTileStats();
            
            console.log('Tiles assigned:', { type: assignType, count: selectedTiles.size });
            console.log('Current manual classification:', manualClassification);
            
            // Clear selection after assignment
            selectedTiles.clear();
            displayTiles();
        }

        let paintTile = null;

        function togglePaintMode() {
            paintMode = !paintMode;
            const button = document.getElementById('paintModeBtn');
            
            if (paintMode) {
                // No longer require a tile to be selected - user can select from popup
                button.textContent = 'Disable Paint Mode';
                button.style.backgroundColor = '#e53e3e';
                showPaintInstructions();
            } else {
                button.textContent = 'Enable Paint Mode';
                button.style.backgroundColor = '#4a5568';
                hidePaintInstructions();
            }
        }

        function showPaintInstructions() {
            const instructions = document.getElementById('paintInstructions');
            if (!instructions) {
                const div = document.createElement('div');
                div.id = 'paintInstructions';
                div.innerHTML = `
                    <div style="background: rgba(66, 153, 225, 0.1); border: 1px solid #4299e1; padding: 10px; margin: 10px 0; border-radius: 4px;">
                        <strong>Paint Mode Active:</strong> Click tile preview to select paint tile, then click and drag on the map to paint
                    </div>
                `;
                document.getElementById('paintSection').appendChild(div);
            }
        }

        function hidePaintInstructions() {
            const instructions = document.getElementById('paintInstructions');
            if (instructions) {
                instructions.remove();
            }
        }

        // Add click handler to output canvas for paint mode
        function setupPaintMode() {
            const outputCanvas = document.getElementById('outputCanvas');
            if (!outputCanvas) return;
            
            let isPainting = false;
            
            function paintAtPosition(e) {
                if (!paintMode || paintTileIndex === null || !currentMap) return;
                
                const rect = outputCanvas.getBoundingClientRect();
                const tileSize = parseInt(document.getElementById('tileSize').value);
                const x = Math.floor((e.clientX - rect.left) / tileSize);
                const y = Math.floor((e.clientY - rect.top) / tileSize);
                
                if (x >= 0 && x < currentMap[0].length && y >= 0 && y < currentMap.length) {
                    currentMap[y][x] = paintTileIndex;
                    renderMap(currentMap);
                }
            }
            
            outputCanvas.addEventListener('mousedown', function(e) {
                if (!paintMode || paintTileIndex === null) {
                    if (paintMode && paintTileIndex === null) {
                        showTileSelector();
                    }
                    return;
                }
                isPainting = true;
                paintAtPosition(e);
                e.preventDefault();
            });
            
            outputCanvas.addEventListener('mousemove', function(e) {
                if (isPainting) {
                    paintAtPosition(e);
                }
                
                // Change cursor when in paint mode
                if (paintMode && paintTileIndex !== null) {
                    this.style.cursor = 'crosshair';
                } else if (paintMode) {
                    this.style.cursor = 'pointer';
                } else {
                    this.style.cursor = 'default';
                }
            });
            
            outputCanvas.addEventListener('mouseup', function() {
                isPainting = false;
            });
            
            outputCanvas.addEventListener('mouseleave', function() {
                isPainting = false;
            });
            
            // Handle click (for single clicks)
            outputCanvas.addEventListener('click', function(e) {
                if (!isPainting) {
                    paintAtPosition(e);
                }
            });
        }

        function generateMap() {
            if (!tilesetImage || tiles.length === 0) {
                showStatus('Please upload a tileset and extract tiles first', 'error');
                return;
            }

            const mapSize = parseInt(document.getElementById('mapSize').value);
            const environmentType = document.getElementById('environmentType').value;
            
            // Group tiles by type - prioritize manual classification, fallback to auto-classification
            const tilesByType = { floor: [], wall: [], decoration: [] };
            
            // Check if we have manual classifications
            const hasManualClassifications = Object.values(manualClassification).some(arr => arr.length > 0);
            
            if (hasManualClassifications) {
                // Use manual classification
                Object.keys(manualClassification).forEach(type => {
                    manualClassification[type].forEach(tileIndex => {
                        tilesByType[type].push(tileIndex);
                    });
                });
            } else {
                // Use auto-classification from selected tiles
                selectedTiles.forEach(index => {
                    const classification = tileClassifications.get(index) || 'floor';
                    tilesByType[classification].push(index);
                });
            }
            
            // Ensure we have at least some tiles
            const totalTiles = Object.values(tilesByType).reduce((sum, arr) => sum + arr.length, 0);
            if (totalTiles === 0) {
                showStatus('Please select some tiles or assign tile classifications', 'error');
                return;
            }
            
            // Generate map using the MapGenerator
            const map = MapGenerator.generate(mapSize, mapSize, tilesByType, environmentType);
            currentMap = map; // Store for paint mode
            
            // Render map
            renderMap(map);
            showStatus('Map generated successfully!', 'success');
        }

        function renderMap(map) {
            const canvas = document.getElementById('outputCanvas');
            if (!canvas) {
                showStatus('Canvas not found', 'error');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            const tileSize = parseInt(document.getElementById('tileSize').value);
            
            canvas.width = map[0].length * tileSize;
            canvas.height = map.length * tileSize;
            
            // Clear canvas
            ctx.fillStyle = '#222';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw tiles
            let imagesLoaded = 0;
            const totalImages = map.length * map[0].length;
            
            map.forEach((row, y) => {
                row.forEach((tileIndex, x) => {
                    if (tileIndex !== null && tileIndex !== undefined && tiles[tileIndex]) {
                        const img = new Image();
                        img.onload = () => {
                            ctx.drawImage(img, x * tileSize, y * tileSize, tileSize, tileSize);
                            imagesLoaded++;
                        };
                        img.onerror = () => {
                            imagesLoaded++;
                        };
                        img.src = tiles[tileIndex];
                    } else {
                        imagesLoaded++;
                    }
                });
            });
        }

        function exportMap() {
            const canvas = document.getElementById('outputCanvas');
            if (!canvas || !currentMap) {
                showStatus('No map to export', 'error');
                return;
            }
            
            const link = document.createElement('a');
            link.download = 'generated-map.png';
            link.href = canvas.toDataURL();
            link.click();
            showStatus('Map exported as PNG!', 'success');
        }

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
            
            setTimeout(() => {
                status.style.display = 'none';
            }, 3000);
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Set up paint mode after a short delay to ensure DOM is ready
            setTimeout(() => {
                setupPaintMode();
                
                // Initialize the output canvas with a placeholder
                const canvas = document.getElementById('outputCanvas');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    canvas.width = 512;
                    canvas.height = 512;
                    
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#333';
                    ctx.font = '20px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('Generated map will appear here', canvas.width/2, canvas.height/2);
                }
            }, 100);
        });
    </script>
</body>
</html>